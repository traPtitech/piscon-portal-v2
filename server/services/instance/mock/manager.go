// Code generated by MockGen. DO NOT EDIT.
// Source: manager.go
//
// Generated by this command:
//
//	mockgen -source=manager.go -destination=mock/manager.go -package=mock -typed=true
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	domain "github.com/traPtitech/piscon-portal-v2/server/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockManager is a mock of Manager interface.
type MockManager struct {
	ctrl     *gomock.Controller
	recorder *MockManagerMockRecorder
	isgomock struct{}
}

// MockManagerMockRecorder is the mock recorder for MockManager.
type MockManagerMockRecorder struct {
	mock *MockManager
}

// NewMockManager creates a new mock instance.
func NewMockManager(ctrl *gomock.Controller) *MockManager {
	mock := &MockManager{ctrl: ctrl}
	mock.recorder = &MockManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockManager) EXPECT() *MockManagerMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockManager) Create(ctx context.Context, name string, githubIDs []string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, name, githubIDs)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockManagerMockRecorder) Create(ctx, name, githubIDs any) *MockManagerCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockManager)(nil).Create), ctx, name, githubIDs)
	return &MockManagerCreateCall{Call: call}
}

// MockManagerCreateCall wrap *gomock.Call
type MockManagerCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockManagerCreateCall) Return(arg0 string, arg1 error) *MockManagerCreateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockManagerCreateCall) Do(f func(context.Context, string, []string) (string, error)) *MockManagerCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockManagerCreateCall) DoAndReturn(f func(context.Context, string, []string) (string, error)) *MockManagerCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockManager) Delete(ctx context.Context, instance domain.InfraInstance) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, instance)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockManagerMockRecorder) Delete(ctx, instance any) *MockManagerDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockManager)(nil).Delete), ctx, instance)
	return &MockManagerDeleteCall{Call: call}
}

// MockManagerDeleteCall wrap *gomock.Call
type MockManagerDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockManagerDeleteCall) Return(arg0 error) *MockManagerDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockManagerDeleteCall) Do(f func(context.Context, domain.InfraInstance) error) *MockManagerDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockManagerDeleteCall) DoAndReturn(f func(context.Context, domain.InfraInstance) error) *MockManagerDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockManager) Get(ctx context.Context, id string) (domain.InfraInstance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, id)
	ret0, _ := ret[0].(domain.InfraInstance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockManagerMockRecorder) Get(ctx, id any) *MockManagerGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockManager)(nil).Get), ctx, id)
	return &MockManagerGetCall{Call: call}
}

// MockManagerGetCall wrap *gomock.Call
type MockManagerGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockManagerGetCall) Return(arg0 domain.InfraInstance, arg1 error) *MockManagerGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockManagerGetCall) Do(f func(context.Context, string) (domain.InfraInstance, error)) *MockManagerGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockManagerGetCall) DoAndReturn(f func(context.Context, string) (domain.InfraInstance, error)) *MockManagerGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAll mocks base method.
func (m *MockManager) GetAll(ctx context.Context) ([]domain.InfraInstance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAll", ctx)
	ret0, _ := ret[0].([]domain.InfraInstance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAll indicates an expected call of GetAll.
func (mr *MockManagerMockRecorder) GetAll(ctx any) *MockManagerGetAllCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockManager)(nil).GetAll), ctx)
	return &MockManagerGetAllCall{Call: call}
}

// MockManagerGetAllCall wrap *gomock.Call
type MockManagerGetAllCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockManagerGetAllCall) Return(arg0 []domain.InfraInstance, arg1 error) *MockManagerGetAllCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockManagerGetAllCall) Do(f func(context.Context) ([]domain.InfraInstance, error)) *MockManagerGetAllCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockManagerGetAllCall) DoAndReturn(f func(context.Context) ([]domain.InfraInstance, error)) *MockManagerGetAllCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetByIDs mocks base method.
func (m *MockManager) GetByIDs(ctx context.Context, ids []string) ([]domain.InfraInstance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByIDs", ctx, ids)
	ret0, _ := ret[0].([]domain.InfraInstance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByIDs indicates an expected call of GetByIDs.
func (mr *MockManagerMockRecorder) GetByIDs(ctx, ids any) *MockManagerGetByIDsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByIDs", reflect.TypeOf((*MockManager)(nil).GetByIDs), ctx, ids)
	return &MockManagerGetByIDsCall{Call: call}
}

// MockManagerGetByIDsCall wrap *gomock.Call
type MockManagerGetByIDsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockManagerGetByIDsCall) Return(arg0 []domain.InfraInstance, arg1 error) *MockManagerGetByIDsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockManagerGetByIDsCall) Do(f func(context.Context, []string) ([]domain.InfraInstance, error)) *MockManagerGetByIDsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockManagerGetByIDsCall) DoAndReturn(f func(context.Context, []string) ([]domain.InfraInstance, error)) *MockManagerGetByIDsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockManager) Start(ctx context.Context, instance domain.InfraInstance) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx, instance)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockManagerMockRecorder) Start(ctx, instance any) *MockManagerStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockManager)(nil).Start), ctx, instance)
	return &MockManagerStartCall{Call: call}
}

// MockManagerStartCall wrap *gomock.Call
type MockManagerStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockManagerStartCall) Return(arg0 error) *MockManagerStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockManagerStartCall) Do(f func(context.Context, domain.InfraInstance) error) *MockManagerStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockManagerStartCall) DoAndReturn(f func(context.Context, domain.InfraInstance) error) *MockManagerStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockManager) Stop(ctx context.Context, instance domain.InfraInstance) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", ctx, instance)
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockManagerMockRecorder) Stop(ctx, instance any) *MockManagerStopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockManager)(nil).Stop), ctx, instance)
	return &MockManagerStopCall{Call: call}
}

// MockManagerStopCall wrap *gomock.Call
type MockManagerStopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockManagerStopCall) Return(arg0 error) *MockManagerStopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockManagerStopCall) Do(f func(context.Context, domain.InfraInstance) error) *MockManagerStopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockManagerStopCall) DoAndReturn(f func(context.Context, domain.InfraInstance) error) *MockManagerStopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
