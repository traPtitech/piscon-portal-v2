// Code generated by BobGen mysql v0.40.2. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package enums

import (
	"database/sql/driver"
	"fmt"
)

// Enum values for BenchmarksResult
const (
	BenchmarksResultPassed BenchmarksResult = "passed"
	BenchmarksResultFailed BenchmarksResult = "failed"
	BenchmarksResultError  BenchmarksResult = "error"
)

func AllBenchmarksResult() []BenchmarksResult {
	return []BenchmarksResult{
		BenchmarksResultPassed,
		BenchmarksResultFailed,
		BenchmarksResultError,
	}
}

type BenchmarksResult string

func (e BenchmarksResult) String() string {
	return string(e)
}

func (e BenchmarksResult) Valid() bool {
	switch e {
	case BenchmarksResultPassed,
		BenchmarksResultFailed,
		BenchmarksResultError:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e BenchmarksResult) All() []BenchmarksResult {
	return AllBenchmarksResult()
}

func (e BenchmarksResult) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *BenchmarksResult) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e BenchmarksResult) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *BenchmarksResult) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e BenchmarksResult) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *BenchmarksResult) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = BenchmarksResult(x)
	case []byte:
		*e = BenchmarksResult(x)
	case nil:
		return fmt.Errorf("cannot nil into BenchmarksResult")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid BenchmarksResult value: %s", *e)
	}

	return nil
}

// Enum values for BenchmarksStatus
const (
	BenchmarksStatusWaiting  BenchmarksStatus = "waiting"
	BenchmarksStatusReadying BenchmarksStatus = "readying"
	BenchmarksStatusRunning  BenchmarksStatus = "running"
	BenchmarksStatusFinished BenchmarksStatus = "finished"
)

func AllBenchmarksStatus() []BenchmarksStatus {
	return []BenchmarksStatus{
		BenchmarksStatusWaiting,
		BenchmarksStatusReadying,
		BenchmarksStatusRunning,
		BenchmarksStatusFinished,
	}
}

type BenchmarksStatus string

func (e BenchmarksStatus) String() string {
	return string(e)
}

func (e BenchmarksStatus) Valid() bool {
	switch e {
	case BenchmarksStatusWaiting,
		BenchmarksStatusReadying,
		BenchmarksStatusRunning,
		BenchmarksStatusFinished:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e BenchmarksStatus) All() []BenchmarksStatus {
	return AllBenchmarksStatus()
}

func (e BenchmarksStatus) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *BenchmarksStatus) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e BenchmarksStatus) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *BenchmarksStatus) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e BenchmarksStatus) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *BenchmarksStatus) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = BenchmarksStatus(x)
	case []byte:
		*e = BenchmarksStatus(x)
	case nil:
		return fmt.Errorf("cannot nil into BenchmarksStatus")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid BenchmarksStatus value: %s", *e)
	}

	return nil
}
