// Code generated by BobGen mysql v0.36.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"testing"

	"github.com/aarondl/opt/omit"
	"github.com/jaswdr/faker/v2"
	"github.com/stephenafamo/bob"
	models "github.com/traPtitech/piscon-portal-v2/server/repository/db/models"
)

type BenchmarkLogMod interface {
	Apply(context.Context, *BenchmarkLogTemplate)
}

type BenchmarkLogModFunc func(context.Context, *BenchmarkLogTemplate)

func (f BenchmarkLogModFunc) Apply(ctx context.Context, n *BenchmarkLogTemplate) {
	f(ctx, n)
}

type BenchmarkLogModSlice []BenchmarkLogMod

func (mods BenchmarkLogModSlice) Apply(ctx context.Context, n *BenchmarkLogTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// BenchmarkLogTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type BenchmarkLogTemplate struct {
	BenchmarkID func() string
	UserLog     func() string
	AdminLog    func() string

	r benchmarkLogR
	f *Factory
}

type benchmarkLogR struct {
	Benchmark *benchmarkLogRBenchmarkR
}

type benchmarkLogRBenchmarkR struct {
	o *BenchmarkTemplate
}

// Apply mods to the BenchmarkLogTemplate
func (o *BenchmarkLogTemplate) Apply(ctx context.Context, mods ...BenchmarkLogMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// toModel returns an *models.BenchmarkLog
// this does nothing with the relationship templates
func (o BenchmarkLogTemplate) toModel() *models.BenchmarkLog {
	m := &models.BenchmarkLog{}

	if o.BenchmarkID != nil {
		m.BenchmarkID = o.BenchmarkID()
	}
	if o.UserLog != nil {
		m.UserLog = o.UserLog()
	}
	if o.AdminLog != nil {
		m.AdminLog = o.AdminLog()
	}

	return m
}

// toModels returns an models.BenchmarkLogSlice
// this does nothing with the relationship templates
func (o BenchmarkLogTemplate) toModels(number int) models.BenchmarkLogSlice {
	m := make(models.BenchmarkLogSlice, number)

	for i := range m {
		m[i] = o.toModel()
	}

	return m
}

// setModelRels creates and sets the relationships on *models.BenchmarkLog
// according to the relationships in the template. Nothing is inserted into the db
func (t BenchmarkLogTemplate) setModelRels(o *models.BenchmarkLog) {
	if t.r.Benchmark != nil {
		rel := t.r.Benchmark.o.toModel()
		rel.R.BenchmarkLog = o
		o.BenchmarkID = rel.ID
		o.R.Benchmark = rel
	}
}

// BuildSetter returns an *models.BenchmarkLogSetter
// this does nothing with the relationship templates
func (o BenchmarkLogTemplate) BuildSetter() *models.BenchmarkLogSetter {
	m := &models.BenchmarkLogSetter{}

	if o.BenchmarkID != nil {
		m.BenchmarkID = omit.From(o.BenchmarkID())
	}
	if o.UserLog != nil {
		m.UserLog = omit.From(o.UserLog())
	}
	if o.AdminLog != nil {
		m.AdminLog = omit.From(o.AdminLog())
	}

	return m
}

// BuildManySetter returns an []*models.BenchmarkLogSetter
// this does nothing with the relationship templates
func (o BenchmarkLogTemplate) BuildManySetter(number int) []*models.BenchmarkLogSetter {
	m := make([]*models.BenchmarkLogSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.BenchmarkLog
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use BenchmarkLogTemplate.Create
func (o BenchmarkLogTemplate) Build() *models.BenchmarkLog {
	m := o.toModel()
	o.setModelRels(m)

	return m
}

// BuildMany returns an models.BenchmarkLogSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use BenchmarkLogTemplate.CreateMany
func (o BenchmarkLogTemplate) BuildMany(number int) models.BenchmarkLogSlice {
	m := make(models.BenchmarkLogSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableBenchmarkLog(m *models.BenchmarkLogSetter) {
	if m.BenchmarkID.IsUnset() {
		m.BenchmarkID = omit.From(random_string(nil, "36"))
	}
	if m.UserLog.IsUnset() {
		m.UserLog = omit.From(random_string(nil))
	}
	if m.AdminLog.IsUnset() {
		m.AdminLog = omit.From(random_string(nil))
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.BenchmarkLog
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *BenchmarkLogTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.BenchmarkLog) (context.Context, error) {
	var err error

	return ctx, err
}

// Create builds a benchmarkLog and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *BenchmarkLogTemplate) Create(ctx context.Context, exec bob.Executor) (*models.BenchmarkLog, error) {
	_, m, err := o.create(ctx, exec)
	return m, err
}

// MustCreate builds a benchmarkLog and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *BenchmarkLogTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.BenchmarkLog {
	_, m, err := o.create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a benchmarkLog and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *BenchmarkLogTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.BenchmarkLog {
	tb.Helper()
	_, m, err := o.create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// create builds a benchmarkLog and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted model
func (o *BenchmarkLogTemplate) create(ctx context.Context, exec bob.Executor) (context.Context, *models.BenchmarkLog, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableBenchmarkLog(opt)

	if o.r.Benchmark == nil {
		BenchmarkLogMods.WithNewBenchmark().Apply(ctx, o)
	}

	ctx, rel0, err := o.r.Benchmark.o.create(ctx, exec)
	if err != nil {
		return ctx, nil, err
	}

	opt.BenchmarkID = omit.From(rel0.ID)

	m, err := models.BenchmarkLogs.Insert(opt).One(ctx, exec)
	if err != nil {
		return ctx, nil, err
	}
	ctx = benchmarkLogCtx.WithValue(ctx, m)

	m.R.Benchmark = rel0

	ctx, err = o.insertOptRels(ctx, exec, m)
	return ctx, m, err
}

// CreateMany builds multiple benchmarkLogs and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o BenchmarkLogTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.BenchmarkLogSlice, error) {
	_, m, err := o.createMany(ctx, exec, number)
	return m, err
}

// MustCreateMany builds multiple benchmarkLogs and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o BenchmarkLogTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.BenchmarkLogSlice {
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple benchmarkLogs and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o BenchmarkLogTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.BenchmarkLogSlice {
	tb.Helper()
	_, m, err := o.createMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// createMany builds multiple benchmarkLogs and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// this returns a context that includes the newly inserted models
func (o BenchmarkLogTemplate) createMany(ctx context.Context, exec bob.Executor, number int) (context.Context, models.BenchmarkLogSlice, error) {
	var err error
	m := make(models.BenchmarkLogSlice, number)

	for i := range m {
		ctx, m[i], err = o.create(ctx, exec)
		if err != nil {
			return ctx, nil, err
		}
	}

	return ctx, m, nil
}

// BenchmarkLog has methods that act as mods for the BenchmarkLogTemplate
var BenchmarkLogMods benchmarkLogMods

type benchmarkLogMods struct{}

func (m benchmarkLogMods) RandomizeAllColumns(f *faker.Faker) BenchmarkLogMod {
	return BenchmarkLogModSlice{
		BenchmarkLogMods.RandomBenchmarkID(f),
		BenchmarkLogMods.RandomUserLog(f),
		BenchmarkLogMods.RandomAdminLog(f),
	}
}

// Set the model columns to this value
func (m benchmarkLogMods) BenchmarkID(val string) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.BenchmarkID = func() string { return val }
	})
}

// Set the Column from the function
func (m benchmarkLogMods) BenchmarkIDFunc(f func() string) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.BenchmarkID = f
	})
}

// Clear any values for the column
func (m benchmarkLogMods) UnsetBenchmarkID() BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.BenchmarkID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m benchmarkLogMods) RandomBenchmarkID(f *faker.Faker) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.BenchmarkID = func() string {
			return random_string(f, "36")
		}
	})
}

// Set the model columns to this value
func (m benchmarkLogMods) UserLog(val string) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.UserLog = func() string { return val }
	})
}

// Set the Column from the function
func (m benchmarkLogMods) UserLogFunc(f func() string) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.UserLog = f
	})
}

// Clear any values for the column
func (m benchmarkLogMods) UnsetUserLog() BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.UserLog = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m benchmarkLogMods) RandomUserLog(f *faker.Faker) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.UserLog = func() string {
			return random_string(f)
		}
	})
}

// Set the model columns to this value
func (m benchmarkLogMods) AdminLog(val string) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.AdminLog = func() string { return val }
	})
}

// Set the Column from the function
func (m benchmarkLogMods) AdminLogFunc(f func() string) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.AdminLog = f
	})
}

// Clear any values for the column
func (m benchmarkLogMods) UnsetAdminLog() BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.AdminLog = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m benchmarkLogMods) RandomAdminLog(f *faker.Faker) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(_ context.Context, o *BenchmarkLogTemplate) {
		o.AdminLog = func() string {
			return random_string(f)
		}
	})
}

func (m benchmarkLogMods) WithParentsCascading() BenchmarkLogMod {
	return BenchmarkLogModFunc(func(ctx context.Context, o *BenchmarkLogTemplate) {
		if isDone, _ := benchmarkLogWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = benchmarkLogWithParentsCascadingCtx.WithValue(ctx, true)
		{

			related := o.f.NewBenchmark(ctx, BenchmarkMods.WithParentsCascading())
			m.WithBenchmark(related).Apply(ctx, o)
		}
	})
}

func (m benchmarkLogMods) WithBenchmark(rel *BenchmarkTemplate) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(ctx context.Context, o *BenchmarkLogTemplate) {
		o.r.Benchmark = &benchmarkLogRBenchmarkR{
			o: rel,
		}
	})
}

func (m benchmarkLogMods) WithNewBenchmark(mods ...BenchmarkMod) BenchmarkLogMod {
	return BenchmarkLogModFunc(func(ctx context.Context, o *BenchmarkLogTemplate) {
		related := o.f.NewBenchmark(ctx, mods...)

		m.WithBenchmark(related).Apply(ctx, o)
	})
}

func (m benchmarkLogMods) WithoutBenchmark() BenchmarkLogMod {
	return BenchmarkLogModFunc(func(ctx context.Context, o *BenchmarkLogTemplate) {
		o.r.Benchmark = nil
	})
}
