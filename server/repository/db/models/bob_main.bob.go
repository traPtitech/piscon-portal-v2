// Code generated by BobGen mysql v0.33.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"
	"strings"

	mysqlDriver "github.com/go-sql-driver/mysql"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/mysql"
	"github.com/stephenafamo/bob/dialect/mysql/dialect"
)

var TableNames = struct {
	BenchmarkLogs string
	Benchmarks    string
	Instances     string
	Sessions      string
	Teams         string
	Users         string
}{
	BenchmarkLogs: "benchmark_logs",
	Benchmarks:    "benchmarks",
	Instances:     "instances",
	Sessions:      "sessions",
	Teams:         "teams",
	Users:         "users",
}

var ColumnNames = struct {
	BenchmarkLogs benchmarkLogColumnNames
	Benchmarks    benchmarkColumnNames
	Instances     instanceColumnNames
	Sessions      sessionColumnNames
	Teams         teamColumnNames
	Users         userColumnNames
}{
	BenchmarkLogs: benchmarkLogColumnNames{
		BenchmarkID: "benchmark_id",
		UserLog:     "user_log",
		AdminLog:    "admin_log",
	},
	Benchmarks: benchmarkColumnNames{
		ID:         "id",
		InstanceID: "instance_id",
		TeamID:     "team_id",
		UserID:     "user_id",
		Status:     "status",
		CreatedAt:  "created_at",
		StartedAt:  "started_at",
		FinishedAt: "finished_at",
		Score:      "score",
		Result:     "result",
	},
	Instances: instanceColumnNames{
		ID:             "id",
		TeamID:         "team_id",
		InstanceNumber: "instance_number",
		Status:         "status",
		CreatedAt:      "created_at",
		PublicIP:       "public_ip",
		PrivateIP:      "private_ip",
	},
	Sessions: sessionColumnNames{
		ID:        "id",
		UserID:    "user_id",
		CreatedAt: "created_at",
		ExpiredAt: "expired_at",
	},
	Teams: teamColumnNames{
		ID:        "id",
		Name:      "name",
		CreatedAt: "created_at",
	},
	Users: userColumnNames{
		ID:      "id",
		Name:    "name",
		TeamID:  "team_id",
		IsAdmin: "is_admin",
	},
}

var (
	SelectWhere = Where[*dialect.SelectQuery]()
	UpdateWhere = Where[*dialect.UpdateQuery]()
	DeleteWhere = Where[*dialect.DeleteQuery]()
)

func Where[Q mysql.Filterable]() struct {
	BenchmarkLogs benchmarkLogWhere[Q]
	Benchmarks    benchmarkWhere[Q]
	Instances     instanceWhere[Q]
	Sessions      sessionWhere[Q]
	Teams         teamWhere[Q]
	Users         userWhere[Q]
} {
	return struct {
		BenchmarkLogs benchmarkLogWhere[Q]
		Benchmarks    benchmarkWhere[Q]
		Instances     instanceWhere[Q]
		Sessions      sessionWhere[Q]
		Teams         teamWhere[Q]
		Users         userWhere[Q]
	}{
		BenchmarkLogs: buildBenchmarkLogWhere[Q](BenchmarkLogColumns),
		Benchmarks:    buildBenchmarkWhere[Q](BenchmarkColumns),
		Instances:     buildInstanceWhere[Q](InstanceColumns),
		Sessions:      buildSessionWhere[Q](SessionColumns),
		Teams:         buildTeamWhere[Q](TeamColumns),
		Users:         buildUserWhere[Q](UserColumns),
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	BenchmarkLogs joinSet[benchmarkLogJoins[Q]]
	Benchmarks    joinSet[benchmarkJoins[Q]]
	Instances     joinSet[instanceJoins[Q]]
	Sessions      joinSet[sessionJoins[Q]]
	Teams         joinSet[teamJoins[Q]]
	Users         joinSet[userJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		BenchmarkLogs: buildJoinSet[benchmarkLogJoins[Q]](BenchmarkLogColumns, buildBenchmarkLogJoins),
		Benchmarks:    buildJoinSet[benchmarkJoins[Q]](BenchmarkColumns, buildBenchmarkJoins),
		Instances:     buildJoinSet[instanceJoins[Q]](InstanceColumns, buildInstanceJoins),
		Sessions:      buildJoinSet[sessionJoins[Q]](SessionColumns, buildSessionJoins),
		Teams:         buildJoinSet[teamJoins[Q]](TeamColumns, buildTeamJoins),
		Users:         buildJoinSet[userJoins[Q]](UserColumns, buildUserJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}

// ErrUniqueConstraint captures all unique constraint errors by explicitly leaving `s` empty.
var ErrUniqueConstraint = &UniqueConstraintError{s: ""}

type UniqueConstraintError struct {
	// s is a string uniquely identifying the constraint in the raw error message returned from the database.
	s string
}

func (e *UniqueConstraintError) Error() string {
	return e.s
}

func (e *UniqueConstraintError) Is(target error) bool {
	err, ok := target.(*mysqlDriver.MySQLError)
	if !ok {
		return false
	}
	return err.Number == 1062 && strings.Contains(err.Message, e.s)
}
