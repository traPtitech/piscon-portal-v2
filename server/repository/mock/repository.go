// Code generated by MockGen. DO NOT EDIT.
// Source: repository.go
//
// Generated by this command:
//
//	mockgen -source=repository.go -destination=mock/repository.go -package=mock -typed=true
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	domain "github.com/traPtitech/piscon-portal-v2/server/domain"
	repository "github.com/traPtitech/piscon-portal-v2/server/repository"
	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// CreateSession mocks base method.
func (m *MockRepository) CreateSession(ctx context.Context, session domain.Session) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateSession", ctx, session)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateSession indicates an expected call of CreateSession.
func (mr *MockRepositoryMockRecorder) CreateSession(ctx, session any) *MockRepositoryCreateSessionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSession", reflect.TypeOf((*MockRepository)(nil).CreateSession), ctx, session)
	return &MockRepositoryCreateSessionCall{Call: call}
}

// MockRepositoryCreateSessionCall wrap *gomock.Call
type MockRepositoryCreateSessionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryCreateSessionCall) Return(arg0 error) *MockRepositoryCreateSessionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryCreateSessionCall) Do(f func(context.Context, domain.Session) error) *MockRepositoryCreateSessionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryCreateSessionCall) DoAndReturn(f func(context.Context, domain.Session) error) *MockRepositoryCreateSessionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateTeam mocks base method.
func (m *MockRepository) CreateTeam(ctx context.Context, team domain.Team) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTeam", ctx, team)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTeam indicates an expected call of CreateTeam.
func (mr *MockRepositoryMockRecorder) CreateTeam(ctx, team any) *MockRepositoryCreateTeamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTeam", reflect.TypeOf((*MockRepository)(nil).CreateTeam), ctx, team)
	return &MockRepositoryCreateTeamCall{Call: call}
}

// MockRepositoryCreateTeamCall wrap *gomock.Call
type MockRepositoryCreateTeamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryCreateTeamCall) Return(arg0 error) *MockRepositoryCreateTeamCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryCreateTeamCall) Do(f func(context.Context, domain.Team) error) *MockRepositoryCreateTeamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryCreateTeamCall) DoAndReturn(f func(context.Context, domain.Team) error) *MockRepositoryCreateTeamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateUser mocks base method.
func (m *MockRepository) CreateUser(ctx context.Context, user domain.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", ctx, user)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockRepositoryMockRecorder) CreateUser(ctx, user any) *MockRepositoryCreateUserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockRepository)(nil).CreateUser), ctx, user)
	return &MockRepositoryCreateUserCall{Call: call}
}

// MockRepositoryCreateUserCall wrap *gomock.Call
type MockRepositoryCreateUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryCreateUserCall) Return(arg0 error) *MockRepositoryCreateUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryCreateUserCall) Do(f func(context.Context, domain.User) error) *MockRepositoryCreateUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryCreateUserCall) DoAndReturn(f func(context.Context, domain.User) error) *MockRepositoryCreateUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteSession mocks base method.
func (m *MockRepository) DeleteSession(ctx context.Context, id string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteSession", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteSession indicates an expected call of DeleteSession.
func (mr *MockRepositoryMockRecorder) DeleteSession(ctx, id any) *MockRepositoryDeleteSessionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSession", reflect.TypeOf((*MockRepository)(nil).DeleteSession), ctx, id)
	return &MockRepositoryDeleteSessionCall{Call: call}
}

// MockRepositoryDeleteSessionCall wrap *gomock.Call
type MockRepositoryDeleteSessionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryDeleteSessionCall) Return(arg0 error) *MockRepositoryDeleteSessionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryDeleteSessionCall) Do(f func(context.Context, string) error) *MockRepositoryDeleteSessionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryDeleteSessionCall) DoAndReturn(f func(context.Context, string) error) *MockRepositoryDeleteSessionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindSession mocks base method.
func (m *MockRepository) FindSession(ctx context.Context, id string) (domain.Session, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindSession", ctx, id)
	ret0, _ := ret[0].(domain.Session)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindSession indicates an expected call of FindSession.
func (mr *MockRepositoryMockRecorder) FindSession(ctx, id any) *MockRepositoryFindSessionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindSession", reflect.TypeOf((*MockRepository)(nil).FindSession), ctx, id)
	return &MockRepositoryFindSessionCall{Call: call}
}

// MockRepositoryFindSessionCall wrap *gomock.Call
type MockRepositoryFindSessionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindSessionCall) Return(arg0 domain.Session, arg1 error) *MockRepositoryFindSessionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindSessionCall) Do(f func(context.Context, string) (domain.Session, error)) *MockRepositoryFindSessionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindSessionCall) DoAndReturn(f func(context.Context, string) (domain.Session, error)) *MockRepositoryFindSessionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindTeam mocks base method.
func (m *MockRepository) FindTeam(ctx context.Context, id string) (domain.Team, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindTeam", ctx, id)
	ret0, _ := ret[0].(domain.Team)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindTeam indicates an expected call of FindTeam.
func (mr *MockRepositoryMockRecorder) FindTeam(ctx, id any) *MockRepositoryFindTeamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindTeam", reflect.TypeOf((*MockRepository)(nil).FindTeam), ctx, id)
	return &MockRepositoryFindTeamCall{Call: call}
}

// MockRepositoryFindTeamCall wrap *gomock.Call
type MockRepositoryFindTeamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindTeamCall) Return(arg0 domain.Team, arg1 error) *MockRepositoryFindTeamCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindTeamCall) Do(f func(context.Context, string) (domain.Team, error)) *MockRepositoryFindTeamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindTeamCall) DoAndReturn(f func(context.Context, string) (domain.Team, error)) *MockRepositoryFindTeamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindUser mocks base method.
func (m *MockRepository) FindUser(ctx context.Context, id string) (domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindUser", ctx, id)
	ret0, _ := ret[0].(domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindUser indicates an expected call of FindUser.
func (mr *MockRepositoryMockRecorder) FindUser(ctx, id any) *MockRepositoryFindUserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUser", reflect.TypeOf((*MockRepository)(nil).FindUser), ctx, id)
	return &MockRepositoryFindUserCall{Call: call}
}

// MockRepositoryFindUserCall wrap *gomock.Call
type MockRepositoryFindUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindUserCall) Return(arg0 domain.User, arg1 error) *MockRepositoryFindUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindUserCall) Do(f func(context.Context, string) (domain.User, error)) *MockRepositoryFindUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindUserCall) DoAndReturn(f func(context.Context, string) (domain.User, error)) *MockRepositoryFindUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTeams mocks base method.
func (m *MockRepository) GetTeams(ctx context.Context) ([]domain.Team, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTeams", ctx)
	ret0, _ := ret[0].([]domain.Team)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTeams indicates an expected call of GetTeams.
func (mr *MockRepositoryMockRecorder) GetTeams(ctx any) *MockRepositoryGetTeamsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTeams", reflect.TypeOf((*MockRepository)(nil).GetTeams), ctx)
	return &MockRepositoryGetTeamsCall{Call: call}
}

// MockRepositoryGetTeamsCall wrap *gomock.Call
type MockRepositoryGetTeamsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryGetTeamsCall) Return(arg0 []domain.Team, arg1 error) *MockRepositoryGetTeamsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryGetTeamsCall) Do(f func(context.Context) ([]domain.Team, error)) *MockRepositoryGetTeamsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryGetTeamsCall) DoAndReturn(f func(context.Context) ([]domain.Team, error)) *MockRepositoryGetTeamsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Transaction mocks base method.
func (m *MockRepository) Transaction(ctx context.Context, f func(context.Context, repository.Repository) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Transaction", ctx, f)
	ret0, _ := ret[0].(error)
	return ret0
}

// Transaction indicates an expected call of Transaction.
func (mr *MockRepositoryMockRecorder) Transaction(ctx, f any) *MockRepositoryTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Transaction", reflect.TypeOf((*MockRepository)(nil).Transaction), ctx, f)
	return &MockRepositoryTransactionCall{Call: call}
}

// MockRepositoryTransactionCall wrap *gomock.Call
type MockRepositoryTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryTransactionCall) Return(arg0 error) *MockRepositoryTransactionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryTransactionCall) Do(f func(context.Context, func(context.Context, repository.Repository) error) error) *MockRepositoryTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryTransactionCall) DoAndReturn(f func(context.Context, func(context.Context, repository.Repository) error) error) *MockRepositoryTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateTeam mocks base method.
func (m *MockRepository) UpdateTeam(ctx context.Context, team domain.Team) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTeam", ctx, team)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateTeam indicates an expected call of UpdateTeam.
func (mr *MockRepositoryMockRecorder) UpdateTeam(ctx, team any) *MockRepositoryUpdateTeamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTeam", reflect.TypeOf((*MockRepository)(nil).UpdateTeam), ctx, team)
	return &MockRepositoryUpdateTeamCall{Call: call}
}

// MockRepositoryUpdateTeamCall wrap *gomock.Call
type MockRepositoryUpdateTeamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryUpdateTeamCall) Return(arg0 error) *MockRepositoryUpdateTeamCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryUpdateTeamCall) Do(f func(context.Context, domain.Team) error) *MockRepositoryUpdateTeamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryUpdateTeamCall) DoAndReturn(f func(context.Context, domain.Team) error) *MockRepositoryUpdateTeamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
