// Code generated by MockGen. DO NOT EDIT.
// Source: usecase.go
//
// Generated by this command:
//
//	mockgen -source=usecase.go -destination=mock/usecase.go -package=mock -typed=true
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"
	time "time"

	uuid "github.com/google/uuid"
	domain "github.com/traPtitech/piscon-portal-v2/server/domain"
	usecase "github.com/traPtitech/piscon-portal-v2/server/usecase"
	gomock "go.uber.org/mock/gomock"
)

// MockUseCase is a mock of UseCase interface.
type MockUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockUseCaseMockRecorder
	isgomock struct{}
}

// MockUseCaseMockRecorder is the mock recorder for MockUseCase.
type MockUseCaseMockRecorder struct {
	mock *MockUseCase
}

// NewMockUseCase creates a new mock instance.
func NewMockUseCase(ctrl *gomock.Controller) *MockUseCase {
	mock := &MockUseCase{ctrl: ctrl}
	mock.recorder = &MockUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUseCase) EXPECT() *MockUseCaseMockRecorder {
	return m.recorder
}

// CreateBenchmark mocks base method.
func (m *MockUseCase) CreateBenchmark(ctx context.Context, instanceID, userID uuid.UUID) (domain.Benchmark, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBenchmark", ctx, instanceID, userID)
	ret0, _ := ret[0].(domain.Benchmark)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateBenchmark indicates an expected call of CreateBenchmark.
func (mr *MockUseCaseMockRecorder) CreateBenchmark(ctx, instanceID, userID any) *MockUseCaseCreateBenchmarkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBenchmark", reflect.TypeOf((*MockUseCase)(nil).CreateBenchmark), ctx, instanceID, userID)
	return &MockUseCaseCreateBenchmarkCall{Call: call}
}

// MockUseCaseCreateBenchmarkCall wrap *gomock.Call
type MockUseCaseCreateBenchmarkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseCreateBenchmarkCall) Return(arg0 domain.Benchmark, arg1 error) *MockUseCaseCreateBenchmarkCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseCreateBenchmarkCall) Do(f func(context.Context, uuid.UUID, uuid.UUID) (domain.Benchmark, error)) *MockUseCaseCreateBenchmarkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseCreateBenchmarkCall) DoAndReturn(f func(context.Context, uuid.UUID, uuid.UUID) (domain.Benchmark, error)) *MockUseCaseCreateBenchmarkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateDocument mocks base method.
func (m *MockUseCase) CreateDocument(ctx context.Context, body string) (domain.Document, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateDocument", ctx, body)
	ret0, _ := ret[0].(domain.Document)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateDocument indicates an expected call of CreateDocument.
func (mr *MockUseCaseMockRecorder) CreateDocument(ctx, body any) *MockUseCaseCreateDocumentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDocument", reflect.TypeOf((*MockUseCase)(nil).CreateDocument), ctx, body)
	return &MockUseCaseCreateDocumentCall{Call: call}
}

// MockUseCaseCreateDocumentCall wrap *gomock.Call
type MockUseCaseCreateDocumentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseCreateDocumentCall) Return(arg0 domain.Document, arg1 error) *MockUseCaseCreateDocumentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseCreateDocumentCall) Do(f func(context.Context, string) (domain.Document, error)) *MockUseCaseCreateDocumentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseCreateDocumentCall) DoAndReturn(f func(context.Context, string) (domain.Document, error)) *MockUseCaseCreateDocumentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateInstance mocks base method.
func (m *MockUseCase) CreateInstance(ctx context.Context, teamID uuid.UUID) (domain.Instance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateInstance", ctx, teamID)
	ret0, _ := ret[0].(domain.Instance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateInstance indicates an expected call of CreateInstance.
func (mr *MockUseCaseMockRecorder) CreateInstance(ctx, teamID any) *MockUseCaseCreateInstanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateInstance", reflect.TypeOf((*MockUseCase)(nil).CreateInstance), ctx, teamID)
	return &MockUseCaseCreateInstanceCall{Call: call}
}

// MockUseCaseCreateInstanceCall wrap *gomock.Call
type MockUseCaseCreateInstanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseCreateInstanceCall) Return(arg0 domain.Instance, arg1 error) *MockUseCaseCreateInstanceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseCreateInstanceCall) Do(f func(context.Context, uuid.UUID) (domain.Instance, error)) *MockUseCaseCreateInstanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseCreateInstanceCall) DoAndReturn(f func(context.Context, uuid.UUID) (domain.Instance, error)) *MockUseCaseCreateInstanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateTeam mocks base method.
func (m *MockUseCase) CreateTeam(ctx context.Context, input usecase.CreateTeamInput) (domain.Team, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTeam", ctx, input)
	ret0, _ := ret[0].(domain.Team)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateTeam indicates an expected call of CreateTeam.
func (mr *MockUseCaseMockRecorder) CreateTeam(ctx, input any) *MockUseCaseCreateTeamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTeam", reflect.TypeOf((*MockUseCase)(nil).CreateTeam), ctx, input)
	return &MockUseCaseCreateTeamCall{Call: call}
}

// MockUseCaseCreateTeamCall wrap *gomock.Call
type MockUseCaseCreateTeamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseCreateTeamCall) Return(arg0 domain.Team, arg1 error) *MockUseCaseCreateTeamCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseCreateTeamCall) Do(f func(context.Context, usecase.CreateTeamInput) (domain.Team, error)) *MockUseCaseCreateTeamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseCreateTeamCall) DoAndReturn(f func(context.Context, usecase.CreateTeamInput) (domain.Team, error)) *MockUseCaseCreateTeamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteInstance mocks base method.
func (m *MockUseCase) DeleteInstance(ctx context.Context, id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteInstance", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteInstance indicates an expected call of DeleteInstance.
func (mr *MockUseCaseMockRecorder) DeleteInstance(ctx, id any) *MockUseCaseDeleteInstanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteInstance", reflect.TypeOf((*MockUseCase)(nil).DeleteInstance), ctx, id)
	return &MockUseCaseDeleteInstanceCall{Call: call}
}

// MockUseCaseDeleteInstanceCall wrap *gomock.Call
type MockUseCaseDeleteInstanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseDeleteInstanceCall) Return(arg0 error) *MockUseCaseDeleteInstanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseDeleteInstanceCall) Do(f func(context.Context, uuid.UUID) error) *MockUseCaseDeleteInstanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseDeleteInstanceCall) DoAndReturn(f func(context.Context, uuid.UUID) error) *MockUseCaseDeleteInstanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FinalizeBenchmark mocks base method.
func (m *MockUseCase) FinalizeBenchmark(ctx context.Context, benchmarkID uuid.UUID, result domain.BenchmarkResult, finishedAt time.Time, errorMessage *string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FinalizeBenchmark", ctx, benchmarkID, result, finishedAt, errorMessage)
	ret0, _ := ret[0].(error)
	return ret0
}

// FinalizeBenchmark indicates an expected call of FinalizeBenchmark.
func (mr *MockUseCaseMockRecorder) FinalizeBenchmark(ctx, benchmarkID, result, finishedAt, errorMessage any) *MockUseCaseFinalizeBenchmarkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FinalizeBenchmark", reflect.TypeOf((*MockUseCase)(nil).FinalizeBenchmark), ctx, benchmarkID, result, finishedAt, errorMessage)
	return &MockUseCaseFinalizeBenchmarkCall{Call: call}
}

// MockUseCaseFinalizeBenchmarkCall wrap *gomock.Call
type MockUseCaseFinalizeBenchmarkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseFinalizeBenchmarkCall) Return(arg0 error) *MockUseCaseFinalizeBenchmarkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseFinalizeBenchmarkCall) Do(f func(context.Context, uuid.UUID, domain.BenchmarkResult, time.Time, *string) error) *MockUseCaseFinalizeBenchmarkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseFinalizeBenchmarkCall) DoAndReturn(f func(context.Context, uuid.UUID, domain.BenchmarkResult, time.Time, *string) error) *MockUseCaseFinalizeBenchmarkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAllInstances mocks base method.
func (m *MockUseCase) GetAllInstances(ctx context.Context) ([]domain.Instance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllInstances", ctx)
	ret0, _ := ret[0].([]domain.Instance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllInstances indicates an expected call of GetAllInstances.
func (mr *MockUseCaseMockRecorder) GetAllInstances(ctx any) *MockUseCaseGetAllInstancesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllInstances", reflect.TypeOf((*MockUseCase)(nil).GetAllInstances), ctx)
	return &MockUseCaseGetAllInstancesCall{Call: call}
}

// MockUseCaseGetAllInstancesCall wrap *gomock.Call
type MockUseCaseGetAllInstancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetAllInstancesCall) Return(arg0 []domain.Instance, arg1 error) *MockUseCaseGetAllInstancesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetAllInstancesCall) Do(f func(context.Context) ([]domain.Instance, error)) *MockUseCaseGetAllInstancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetAllInstancesCall) DoAndReturn(f func(context.Context) ([]domain.Instance, error)) *MockUseCaseGetAllInstancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBenchmark mocks base method.
func (m *MockUseCase) GetBenchmark(ctx context.Context, id uuid.UUID) (domain.Benchmark, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBenchmark", ctx, id)
	ret0, _ := ret[0].(domain.Benchmark)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBenchmark indicates an expected call of GetBenchmark.
func (mr *MockUseCaseMockRecorder) GetBenchmark(ctx, id any) *MockUseCaseGetBenchmarkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBenchmark", reflect.TypeOf((*MockUseCase)(nil).GetBenchmark), ctx, id)
	return &MockUseCaseGetBenchmarkCall{Call: call}
}

// MockUseCaseGetBenchmarkCall wrap *gomock.Call
type MockUseCaseGetBenchmarkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetBenchmarkCall) Return(arg0 domain.Benchmark, arg1 error) *MockUseCaseGetBenchmarkCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetBenchmarkCall) Do(f func(context.Context, uuid.UUID) (domain.Benchmark, error)) *MockUseCaseGetBenchmarkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetBenchmarkCall) DoAndReturn(f func(context.Context, uuid.UUID) (domain.Benchmark, error)) *MockUseCaseGetBenchmarkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBenchmarkLog mocks base method.
func (m *MockUseCase) GetBenchmarkLog(ctx context.Context, benchmarkID uuid.UUID) (domain.BenchmarkLog, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBenchmarkLog", ctx, benchmarkID)
	ret0, _ := ret[0].(domain.BenchmarkLog)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBenchmarkLog indicates an expected call of GetBenchmarkLog.
func (mr *MockUseCaseMockRecorder) GetBenchmarkLog(ctx, benchmarkID any) *MockUseCaseGetBenchmarkLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBenchmarkLog", reflect.TypeOf((*MockUseCase)(nil).GetBenchmarkLog), ctx, benchmarkID)
	return &MockUseCaseGetBenchmarkLogCall{Call: call}
}

// MockUseCaseGetBenchmarkLogCall wrap *gomock.Call
type MockUseCaseGetBenchmarkLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetBenchmarkLogCall) Return(arg0 domain.BenchmarkLog, arg1 error) *MockUseCaseGetBenchmarkLogCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetBenchmarkLogCall) Do(f func(context.Context, uuid.UUID) (domain.BenchmarkLog, error)) *MockUseCaseGetBenchmarkLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetBenchmarkLogCall) DoAndReturn(f func(context.Context, uuid.UUID) (domain.BenchmarkLog, error)) *MockUseCaseGetBenchmarkLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBenchmarks mocks base method.
func (m *MockUseCase) GetBenchmarks(ctx context.Context) ([]domain.Benchmark, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBenchmarks", ctx)
	ret0, _ := ret[0].([]domain.Benchmark)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBenchmarks indicates an expected call of GetBenchmarks.
func (mr *MockUseCaseMockRecorder) GetBenchmarks(ctx any) *MockUseCaseGetBenchmarksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBenchmarks", reflect.TypeOf((*MockUseCase)(nil).GetBenchmarks), ctx)
	return &MockUseCaseGetBenchmarksCall{Call: call}
}

// MockUseCaseGetBenchmarksCall wrap *gomock.Call
type MockUseCaseGetBenchmarksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetBenchmarksCall) Return(arg0 []domain.Benchmark, arg1 error) *MockUseCaseGetBenchmarksCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetBenchmarksCall) Do(f func(context.Context) ([]domain.Benchmark, error)) *MockUseCaseGetBenchmarksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetBenchmarksCall) DoAndReturn(f func(context.Context) ([]domain.Benchmark, error)) *MockUseCaseGetBenchmarksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetDocument mocks base method.
func (m *MockUseCase) GetDocument(ctx context.Context) (domain.Document, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDocument", ctx)
	ret0, _ := ret[0].(domain.Document)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDocument indicates an expected call of GetDocument.
func (mr *MockUseCaseMockRecorder) GetDocument(ctx any) *MockUseCaseGetDocumentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDocument", reflect.TypeOf((*MockUseCase)(nil).GetDocument), ctx)
	return &MockUseCaseGetDocumentCall{Call: call}
}

// MockUseCaseGetDocumentCall wrap *gomock.Call
type MockUseCaseGetDocumentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetDocumentCall) Return(arg0 domain.Document, arg1 error) *MockUseCaseGetDocumentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetDocumentCall) Do(f func(context.Context) (domain.Document, error)) *MockUseCaseGetDocumentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetDocumentCall) DoAndReturn(f func(context.Context) (domain.Document, error)) *MockUseCaseGetDocumentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetQueuedBenchmarks mocks base method.
func (m *MockUseCase) GetQueuedBenchmarks(ctx context.Context) ([]domain.Benchmark, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetQueuedBenchmarks", ctx)
	ret0, _ := ret[0].([]domain.Benchmark)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetQueuedBenchmarks indicates an expected call of GetQueuedBenchmarks.
func (mr *MockUseCaseMockRecorder) GetQueuedBenchmarks(ctx any) *MockUseCaseGetQueuedBenchmarksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetQueuedBenchmarks", reflect.TypeOf((*MockUseCase)(nil).GetQueuedBenchmarks), ctx)
	return &MockUseCaseGetQueuedBenchmarksCall{Call: call}
}

// MockUseCaseGetQueuedBenchmarksCall wrap *gomock.Call
type MockUseCaseGetQueuedBenchmarksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetQueuedBenchmarksCall) Return(arg0 []domain.Benchmark, arg1 error) *MockUseCaseGetQueuedBenchmarksCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetQueuedBenchmarksCall) Do(f func(context.Context) ([]domain.Benchmark, error)) *MockUseCaseGetQueuedBenchmarksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetQueuedBenchmarksCall) DoAndReturn(f func(context.Context) ([]domain.Benchmark, error)) *MockUseCaseGetQueuedBenchmarksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRanking mocks base method.
func (m *MockUseCase) GetRanking(ctx context.Context, query usecase.RankingQuery) ([]usecase.RankingItem, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRanking", ctx, query)
	ret0, _ := ret[0].([]usecase.RankingItem)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRanking indicates an expected call of GetRanking.
func (mr *MockUseCaseMockRecorder) GetRanking(ctx, query any) *MockUseCaseGetRankingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRanking", reflect.TypeOf((*MockUseCase)(nil).GetRanking), ctx, query)
	return &MockUseCaseGetRankingCall{Call: call}
}

// MockUseCaseGetRankingCall wrap *gomock.Call
type MockUseCaseGetRankingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetRankingCall) Return(arg0 []usecase.RankingItem, arg1 error) *MockUseCaseGetRankingCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetRankingCall) Do(f func(context.Context, usecase.RankingQuery) ([]usecase.RankingItem, error)) *MockUseCaseGetRankingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetRankingCall) DoAndReturn(f func(context.Context, usecase.RankingQuery) ([]usecase.RankingItem, error)) *MockUseCaseGetRankingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetScores mocks base method.
func (m *MockUseCase) GetScores(ctx context.Context) ([]usecase.TeamScores, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetScores", ctx)
	ret0, _ := ret[0].([]usecase.TeamScores)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetScores indicates an expected call of GetScores.
func (mr *MockUseCaseMockRecorder) GetScores(ctx any) *MockUseCaseGetScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetScores", reflect.TypeOf((*MockUseCase)(nil).GetScores), ctx)
	return &MockUseCaseGetScoresCall{Call: call}
}

// MockUseCaseGetScoresCall wrap *gomock.Call
type MockUseCaseGetScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetScoresCall) Return(arg0 []usecase.TeamScores, arg1 error) *MockUseCaseGetScoresCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetScoresCall) Do(f func(context.Context) ([]usecase.TeamScores, error)) *MockUseCaseGetScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetScoresCall) DoAndReturn(f func(context.Context) ([]usecase.TeamScores, error)) *MockUseCaseGetScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTeam mocks base method.
func (m *MockUseCase) GetTeam(ctx context.Context, id uuid.UUID) (domain.Team, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTeam", ctx, id)
	ret0, _ := ret[0].(domain.Team)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTeam indicates an expected call of GetTeam.
func (mr *MockUseCaseMockRecorder) GetTeam(ctx, id any) *MockUseCaseGetTeamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTeam", reflect.TypeOf((*MockUseCase)(nil).GetTeam), ctx, id)
	return &MockUseCaseGetTeamCall{Call: call}
}

// MockUseCaseGetTeamCall wrap *gomock.Call
type MockUseCaseGetTeamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetTeamCall) Return(arg0 domain.Team, arg1 error) *MockUseCaseGetTeamCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetTeamCall) Do(f func(context.Context, uuid.UUID) (domain.Team, error)) *MockUseCaseGetTeamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetTeamCall) DoAndReturn(f func(context.Context, uuid.UUID) (domain.Team, error)) *MockUseCaseGetTeamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTeamBenchmarks mocks base method.
func (m *MockUseCase) GetTeamBenchmarks(ctx context.Context, teamID uuid.UUID) ([]domain.Benchmark, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTeamBenchmarks", ctx, teamID)
	ret0, _ := ret[0].([]domain.Benchmark)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTeamBenchmarks indicates an expected call of GetTeamBenchmarks.
func (mr *MockUseCaseMockRecorder) GetTeamBenchmarks(ctx, teamID any) *MockUseCaseGetTeamBenchmarksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTeamBenchmarks", reflect.TypeOf((*MockUseCase)(nil).GetTeamBenchmarks), ctx, teamID)
	return &MockUseCaseGetTeamBenchmarksCall{Call: call}
}

// MockUseCaseGetTeamBenchmarksCall wrap *gomock.Call
type MockUseCaseGetTeamBenchmarksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetTeamBenchmarksCall) Return(arg0 []domain.Benchmark, arg1 error) *MockUseCaseGetTeamBenchmarksCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetTeamBenchmarksCall) Do(f func(context.Context, uuid.UUID) ([]domain.Benchmark, error)) *MockUseCaseGetTeamBenchmarksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetTeamBenchmarksCall) DoAndReturn(f func(context.Context, uuid.UUID) ([]domain.Benchmark, error)) *MockUseCaseGetTeamBenchmarksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTeamInstances mocks base method.
func (m *MockUseCase) GetTeamInstances(ctx context.Context, teamID uuid.UUID) ([]domain.Instance, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTeamInstances", ctx, teamID)
	ret0, _ := ret[0].([]domain.Instance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTeamInstances indicates an expected call of GetTeamInstances.
func (mr *MockUseCaseMockRecorder) GetTeamInstances(ctx, teamID any) *MockUseCaseGetTeamInstancesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTeamInstances", reflect.TypeOf((*MockUseCase)(nil).GetTeamInstances), ctx, teamID)
	return &MockUseCaseGetTeamInstancesCall{Call: call}
}

// MockUseCaseGetTeamInstancesCall wrap *gomock.Call
type MockUseCaseGetTeamInstancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetTeamInstancesCall) Return(arg0 []domain.Instance, arg1 error) *MockUseCaseGetTeamInstancesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetTeamInstancesCall) Do(f func(context.Context, uuid.UUID) ([]domain.Instance, error)) *MockUseCaseGetTeamInstancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetTeamInstancesCall) DoAndReturn(f func(context.Context, uuid.UUID) ([]domain.Instance, error)) *MockUseCaseGetTeamInstancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTeams mocks base method.
func (m *MockUseCase) GetTeams(ctx context.Context) ([]domain.Team, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTeams", ctx)
	ret0, _ := ret[0].([]domain.Team)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTeams indicates an expected call of GetTeams.
func (mr *MockUseCaseMockRecorder) GetTeams(ctx any) *MockUseCaseGetTeamsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTeams", reflect.TypeOf((*MockUseCase)(nil).GetTeams), ctx)
	return &MockUseCaseGetTeamsCall{Call: call}
}

// MockUseCaseGetTeamsCall wrap *gomock.Call
type MockUseCaseGetTeamsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetTeamsCall) Return(arg0 []domain.Team, arg1 error) *MockUseCaseGetTeamsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetTeamsCall) Do(f func(context.Context) ([]domain.Team, error)) *MockUseCaseGetTeamsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetTeamsCall) DoAndReturn(f func(context.Context) ([]domain.Team, error)) *MockUseCaseGetTeamsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUser mocks base method.
func (m *MockUseCase) GetUser(ctx context.Context, userID uuid.UUID) (domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUser", ctx, userID)
	ret0, _ := ret[0].(domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUser indicates an expected call of GetUser.
func (mr *MockUseCaseMockRecorder) GetUser(ctx, userID any) *MockUseCaseGetUserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockUseCase)(nil).GetUser), ctx, userID)
	return &MockUseCaseGetUserCall{Call: call}
}

// MockUseCaseGetUserCall wrap *gomock.Call
type MockUseCaseGetUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetUserCall) Return(arg0 domain.User, arg1 error) *MockUseCaseGetUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetUserCall) Do(f func(context.Context, uuid.UUID) (domain.User, error)) *MockUseCaseGetUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetUserCall) DoAndReturn(f func(context.Context, uuid.UUID) (domain.User, error)) *MockUseCaseGetUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUsers mocks base method.
func (m *MockUseCase) GetUsers(ctx context.Context) ([]domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUsers", ctx)
	ret0, _ := ret[0].([]domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUsers indicates an expected call of GetUsers.
func (mr *MockUseCaseMockRecorder) GetUsers(ctx any) *MockUseCaseGetUsersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsers", reflect.TypeOf((*MockUseCase)(nil).GetUsers), ctx)
	return &MockUseCaseGetUsersCall{Call: call}
}

// MockUseCaseGetUsersCall wrap *gomock.Call
type MockUseCaseGetUsersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseGetUsersCall) Return(arg0 []domain.User, arg1 error) *MockUseCaseGetUsersCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseGetUsersCall) Do(f func(context.Context) ([]domain.User, error)) *MockUseCaseGetUsersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseGetUsersCall) DoAndReturn(f func(context.Context) ([]domain.User, error)) *MockUseCaseGetUsersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PutAdmins mocks base method.
func (m *MockUseCase) PutAdmins(ctx context.Context, loginUserID uuid.UUID, userIDs []uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PutAdmins", ctx, loginUserID, userIDs)
	ret0, _ := ret[0].(error)
	return ret0
}

// PutAdmins indicates an expected call of PutAdmins.
func (mr *MockUseCaseMockRecorder) PutAdmins(ctx, loginUserID, userIDs any) *MockUseCasePutAdminsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PutAdmins", reflect.TypeOf((*MockUseCase)(nil).PutAdmins), ctx, loginUserID, userIDs)
	return &MockUseCasePutAdminsCall{Call: call}
}

// MockUseCasePutAdminsCall wrap *gomock.Call
type MockUseCasePutAdminsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCasePutAdminsCall) Return(arg0 error) *MockUseCasePutAdminsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCasePutAdminsCall) Do(f func(context.Context, uuid.UUID, []uuid.UUID) error) *MockUseCasePutAdminsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCasePutAdminsCall) DoAndReturn(f func(context.Context, uuid.UUID, []uuid.UUID) error) *MockUseCasePutAdminsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveBenchmarkProgress mocks base method.
func (m *MockUseCase) SaveBenchmarkProgress(ctx context.Context, benchmarkID uuid.UUID, benchLog domain.BenchmarkLog, score int64, startedAt time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveBenchmarkProgress", ctx, benchmarkID, benchLog, score, startedAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveBenchmarkProgress indicates an expected call of SaveBenchmarkProgress.
func (mr *MockUseCaseMockRecorder) SaveBenchmarkProgress(ctx, benchmarkID, benchLog, score, startedAt any) *MockUseCaseSaveBenchmarkProgressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveBenchmarkProgress", reflect.TypeOf((*MockUseCase)(nil).SaveBenchmarkProgress), ctx, benchmarkID, benchLog, score, startedAt)
	return &MockUseCaseSaveBenchmarkProgressCall{Call: call}
}

// MockUseCaseSaveBenchmarkProgressCall wrap *gomock.Call
type MockUseCaseSaveBenchmarkProgressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseSaveBenchmarkProgressCall) Return(arg0 error) *MockUseCaseSaveBenchmarkProgressCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseSaveBenchmarkProgressCall) Do(f func(context.Context, uuid.UUID, domain.BenchmarkLog, int64, time.Time) error) *MockUseCaseSaveBenchmarkProgressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseSaveBenchmarkProgressCall) DoAndReturn(f func(context.Context, uuid.UUID, domain.BenchmarkLog, int64, time.Time) error) *MockUseCaseSaveBenchmarkProgressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartBenchmark mocks base method.
func (m *MockUseCase) StartBenchmark(ctx context.Context) (domain.Benchmark, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartBenchmark", ctx)
	ret0, _ := ret[0].(domain.Benchmark)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartBenchmark indicates an expected call of StartBenchmark.
func (mr *MockUseCaseMockRecorder) StartBenchmark(ctx any) *MockUseCaseStartBenchmarkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartBenchmark", reflect.TypeOf((*MockUseCase)(nil).StartBenchmark), ctx)
	return &MockUseCaseStartBenchmarkCall{Call: call}
}

// MockUseCaseStartBenchmarkCall wrap *gomock.Call
type MockUseCaseStartBenchmarkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseStartBenchmarkCall) Return(arg0 domain.Benchmark, arg1 error) *MockUseCaseStartBenchmarkCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseStartBenchmarkCall) Do(f func(context.Context) (domain.Benchmark, error)) *MockUseCaseStartBenchmarkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseStartBenchmarkCall) DoAndReturn(f func(context.Context) (domain.Benchmark, error)) *MockUseCaseStartBenchmarkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateInstance mocks base method.
func (m *MockUseCase) UpdateInstance(ctx context.Context, id uuid.UUID, op domain.InstanceOperation) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateInstance", ctx, id, op)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateInstance indicates an expected call of UpdateInstance.
func (mr *MockUseCaseMockRecorder) UpdateInstance(ctx, id, op any) *MockUseCaseUpdateInstanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateInstance", reflect.TypeOf((*MockUseCase)(nil).UpdateInstance), ctx, id, op)
	return &MockUseCaseUpdateInstanceCall{Call: call}
}

// MockUseCaseUpdateInstanceCall wrap *gomock.Call
type MockUseCaseUpdateInstanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseUpdateInstanceCall) Return(arg0 error) *MockUseCaseUpdateInstanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseUpdateInstanceCall) Do(f func(context.Context, uuid.UUID, domain.InstanceOperation) error) *MockUseCaseUpdateInstanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseUpdateInstanceCall) DoAndReturn(f func(context.Context, uuid.UUID, domain.InstanceOperation) error) *MockUseCaseUpdateInstanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateTeam mocks base method.
func (m *MockUseCase) UpdateTeam(ctx context.Context, input usecase.UpdateTeamInput) (domain.Team, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTeam", ctx, input)
	ret0, _ := ret[0].(domain.Team)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateTeam indicates an expected call of UpdateTeam.
func (mr *MockUseCaseMockRecorder) UpdateTeam(ctx, input any) *MockUseCaseUpdateTeamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTeam", reflect.TypeOf((*MockUseCase)(nil).UpdateTeam), ctx, input)
	return &MockUseCaseUpdateTeamCall{Call: call}
}

// MockUseCaseUpdateTeamCall wrap *gomock.Call
type MockUseCaseUpdateTeamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseUpdateTeamCall) Return(arg0 domain.Team, arg1 error) *MockUseCaseUpdateTeamCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseUpdateTeamCall) Do(f func(context.Context, usecase.UpdateTeamInput) (domain.Team, error)) *MockUseCaseUpdateTeamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseUpdateTeamCall) DoAndReturn(f func(context.Context, usecase.UpdateTeamInput) (domain.Team, error)) *MockUseCaseUpdateTeamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
